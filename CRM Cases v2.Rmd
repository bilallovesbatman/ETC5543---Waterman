---
title: "Waterman Workspaces Customer Churn Analysis: Impact of CRM Cases"
author: "Bilal Raja"
date: "2024-10-02"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE)
```

```{r}
library(tidyverse)
library(readxl)
library(visdat)
library(kableExtra)
library(bookdown)
```

```{r, warning=FALSE}
wmcases <- read_xlsx("data/CRM Cases 1-08-2024 5-17-55 PM.xlsx")
memberships <- read_xlsx("data/All Products 2023 to now.xlsx")

```

## Abstract

This report discusses the customer churn analysis for Waterman Workspaces by using the customers' membership data, together with the data from the Customer Relationship Management (CRM) system to derive insights for investigating the factors that may potentially influence the customers' churn behaviour. Factors such as case escalations, frequency of cases, and time taken to resolve a case were investigated using logistic regression modelling. The purpose of our analysis is to use the findings to guide retention strategies and improve services of the organization.

## Background and Motivation

Waterman Workspaces uses a membership subscription model to run their business which are defined as their 'products'. Some examples of the products include casual hire, team membership, part time membership, and suite among others. Due to an intense market competition in the domain, the organization found it pertinent to investigate customer retention on a precautionary basis in order to uncover an aspect of their business' health. Two of the most crucial areas were analyzing the customers' attendances and foot traffic and case analysis using the data from the CRM. The area to investigate was the CRM for me where the analysis focused on whether the case patterns - that include the number of cases and their resolution time - and their escalation statuses affect the likelihood of churn.

Through the CRM system, Waterman Workspaces keeps a record of the numerous interactions that take place with their customers. However, given the data, it is unclear how the information from the data source correlate with churn. Thus, it is pertinent to investigate the dynamics between the service quality provided by the organization and churn in order to formulate actionable insights and enhance customer satisfaction.

## Objectives and Significance

The objectives and significance of the report include:

- Identifying the key drivers for churn: Assess the variables that influence that lead to customers churning. The variables investigated in the report include the number of cases, their resolution time, case escalations, and whether different sites of Waterman Workspaces have greater churns. Accurate analysis gives birth to formulating targeted strategies.

- Modelling and quantifying the impact: Determining how the potential drivers affect churn likelihood via logistic regression modeling.

- Develop actionable insights for long-term success: Provide data-driven recommendations to the organization that are concise and understood with ease for the business for retention strategies. Fostering informed decision-making leads to enhanced overall business performance.


## Methodology

The data was provided the host organization in the form of 2 primary datasets; CRM Cases data (`wmcases`) and membership data (`memberships`). 

The CRM Cases data output is seen below where we can see the variables that come along with it followed by the variables in the memberships data.

```{r var-table-cases, echo=FALSE, }
# Extract column names
variable_list <- as.data.frame(matrix(names(wmcases), ncol = 2, byrow = TRUE))

# Add column headers
colnames(variable_list) <- c("Variables", "Variables")

# Display the variables in a two-column table

kable(variable_list, 
      caption = "List of Variables in the `wmcases` Dataset", 
      align = "l")
```

```{r var-table-member, echo=FALSE}
# Extract column names
variable_list2 <- as.data.frame(matrix(names(memberships), ncol = 2, byrow = TRUE))

# Add column headers
colnames(variable_list2) <- c("Variables", "Variables")

# Display the variables in a two-column table
kable(variable_list2, 
      caption = "List of Variables in the `memberships` Dataset", 
      align = "l")
```

Upon consultation with the relevant personnel in the organization, the variables and observations that were not needed were removed from our analysis. Moreover, since the key variable was the *Account Number* of the customers, due diligence was made to ensure blanks and non-customer observations were removed as well. When the irrelevant observations and variables were removed, the 2 datasets were joined using a left join by using the `Account Number` as the key variable. The left join was essential as it retained all records of the CRM data and the matching records of the memberships data so that every case lodged in the CRM system was included in the analysis even if some memberships data for customers was missing. In theory, this approach factors in customers that may have recently joined in or left already.

```{r}
cases_clean <- wmcases |>
  filter(!grepl("Product delivery", Subject, ignore.case = TRUE) &
           !grepl("ETC waiver", Subject, ignore.case = TRUE) &
           !grepl("Financial request", Subject, ignore.case = TRUE) &
           !grepl("Purchase orders", Subject, ignore.case = TRUE) &
           !grepl("Rent/Membership assistance", Subject, ignore.case = TRUE) &
           !grepl("All retired ones", Subject, ignore.case = TRUE) &
           !grepl("\\(RETIRED\\)", Subject, ignore.case = TRUE)) |>
  filter(!is.na(`Account Number (Customer) (Account)`)) |>
  rename(`Account Number` = `Account Number (Customer) (Account)`) |>
  select(-`(Do Not Modify) Case`, -`(Do Not Modify) Row Checksum`, -`(Do Not Modify) Modified On`)

member_clean <- memberships |>
  filter(!grepl("Quote Duplicate", `Status Reason`, ignore.case = TRUE)) |>
  filter(!grepl("Casual Hire", `Accounting Code`, ignore.case = TRUE)) |>
  filter(!is.na(`Account Number (Lessee) (Account)`)) |>
  rename(`Account Number` = `Account Number (Lessee) (Account)`)

```

```{r}
cases_joined <- left_join(cases_clean, member_clean, by = "Account Number")

```

The merged data produced a large dataset with an increasing number of variables that needed to be cleaned further. As before, potential `NA` values were catered for and further nonessential variables and observations were removed. The resulting dataset had the following useful variables for our analysis:


```{r}
cases_joined <- cases_joined |>
  select(`Account Number`, `Customer`, `Case Number`, `Case Title`, `Case Age`, `Case Age (Days)`, 
         `Is Escalated`, everything(), -Priority, -`Modified On`, -Satisfaction, -`Sentiment Value`, 
         -`Service Level`, -SLA, -Severity, -Status.y, -`Product Name`, -Location, -`Accounting Code`, 
         -`Status Reason.x`, -`Industry (Lessee) (Account)`, -Lessee) |>
  mutate(
    Site = as.factor(Site),
    `Product Category` = as.factor(`Product Category`)) |>
  filter(!grepl("TestPayment", `Account Number`, ignore.case = TRUE)) |>
  filter(!grepl("Waterman Workspaces", `Customer`, ignore.case = TRUE))

```

```{r}
# Extract column names and format them into two columns
variable_list3 <- as.data.frame(matrix(names(cases_joined), ncol = 2, byrow = TRUE))

# Add column headers
colnames(variable_list3) <- c("Variables", "Variables")

# Display the table with a caption
library(knitr)
kable(variable_list3, 
      caption = "Variables in the `cases_joined` Dataset", 
      align = "l")
```



```{r}
churn_statuses <- c("Inactive - Customer Cancelled", "Off-boarding", "Inactive")

cases_filtered <- cases_joined |>
  filter(`Status Reason.y` %in% churn_statuses | is.na(`Status Reason.y`)) |>
  mutate(`Is Escalated` = ifelse(`Is Escalated` == "Yes", 1, 0))

```

```{r}
cases_count <- cases_filtered |>
  group_by(`Account Number`) |>
  summarise(num_cases = n())
```

```{r}
avg_case_age <- cases_filtered |>
  group_by(`Account Number`) |>
  summarise(avg_case_age = median(`Case Age (Days)`, na.rm = TRUE))

```


```{r}
customer_features <- cases_count |>
  inner_join(avg_case_age, by = "Account Number")
```

```{r}
customer_features <- cases_filtered |>
  group_by(`Account Number`) |>
  summarise(
    num_cases = n(),
    avg_case_age = median(`Case Age (Days)`, na.rm = TRUE),
    churned = as.integer(any(`Status Reason.y` %in% churn_statuses)),
    product_category = first(`Product Category`),  # Ensure logical first() use
    site = first(`Site`),  # Assuming consistent site for account
    is_escalated = max(`Is Escalated`, na.rm = TRUE)  # Escalation as binary
  )

# Ensure 'product_category' and 'site' remain as factors
customer_features <- customer_features |>
  mutate(
    product_category = as.factor(product_category),
    site = as.factor(site)
  )

```

```{r}
ggplot(customer_features, aes(x = num_cases, fill = as.factor(churned))) +
  geom_histogram(position = "dodge", binwidth = 1) +
  labs(title = "Distribution of Number of Cases", x = "Number of Cases", fill = "Churned")

ggplot(customer_features, aes(x = avg_case_age, fill = as.factor(churned))) +
  geom_histogram(position = "dodge", binwidth = 1) +
  labs(title = "Distribution of Average Case Age", x = "Average Case Age (Days)", fill = "Churned")

```

```{r}
# Outlier detection for average case age
Q1_age <- quantile(customer_features$avg_case_age, 0.25, na.rm = TRUE)
Q3_age <- quantile(customer_features$avg_case_age, 0.75, na.rm = TRUE)
IQR_age <- Q3_age - Q1_age

lower_bound_age <- Q1_age - 1.5 * IQR_age
upper_bound_age <- Q3_age + 1.5 * IQR_age

customer_features_clean <- customer_features |>
  filter(avg_case_age >= lower_bound_age & avg_case_age <= upper_bound_age)

# Outlier detection for number of cases
Q1_num <- quantile(customer_features_clean$num_cases, 0.25, na.rm = TRUE)
Q3_num <- quantile(customer_features_clean$num_cases, 0.75, na.rm = TRUE)
IQR_num <- Q3_num - Q1_num

lower_bound_num <- Q1_num - 1.5 * IQR_num
upper_bound_num <- Q3_num + 1.5 * IQR_num

customer_features_clean <- customer_features_clean |>
  filter(num_cases >= lower_bound_num & num_cases <= upper_bound_num)

```

```{r}
ggplot(customer_features_clean, aes(x = num_cases, fill = as.factor(churned))) +
  geom_histogram(position = "dodge", binwidth = 1) +
  labs(title = "Distribution of Number of Cases", x = "Number of Cases", fill = "Churned")

ggplot(customer_features_clean, aes(x = avg_case_age, fill = as.factor(churned))) +
  geom_histogram(position = "dodge", binwidth = 1) +
  labs(title = "Distribution of Average Case Age", x = "Average Case Age (Days)", fill = "Churned")
```

```{r}
cor(customer_features_clean |> select(num_cases, avg_case_age, is_escalated, churned))

```

```{r}
log_model <- glm(churned ~ num_cases + avg_case_age + is_escalated + site, data = customer_features_clean, family = binomial)
summary(log_model)

```

```{r}
# Create interaction terms
customer_features_clean <- customer_features_clean %>%
  mutate(
    num_cases_escalated = num_cases * is_escalated,
    case_age_escalated = avg_case_age * is_escalated,
    site_escalated = interaction(site, is_escalated)
  )

```


```{r}
int_model <- glm(churned ~ num_cases + avg_case_age + is_escalated + site + num_cases_escalated + case_age_escalated, data = customer_features_clean, family = binomial)

summary(int_model)
```

```{r}
# Compare models using AIC and BIC
AIC(log_model, int_model)
BIC(log_model, int_model)

```


```{r}
cases_summary <- cases_joined %>%
  filter(`Status Reason.y` %in% churn_statuses) %>%
  group_by(`Account Number`, Customer, `Status Reason.y`) %>%
  summarize(
    total_cases = n(),
    avg_case_age = mean(`Case Age (Days)`, na.rm = TRUE),
    .groups = 'drop'
  )

# Step 2: Clean the summary
cases_summary_clean <- cases_summary %>%
  filter(!is.na(total_cases) & !is.na(avg_case_age))

ggplot(cases_summary, aes(x = total_cases)) +
  geom_bar(fill = "steelblue") +
  labs(title = "Number of Cases for Churned Customers", x = "Number of Cases", y = "Count of Customers")

ggplot(cases_summary, aes(x = "", y = avg_case_age)) +
  geom_boxplot(fill = "lightgreen") +
  labs(title = "Case Resolution Time for Churned Customers", y = "Average Case Age (Days)") +
  theme(axis.text.x = element_blank())

```


